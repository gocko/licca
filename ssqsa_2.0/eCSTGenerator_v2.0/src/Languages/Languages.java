package Languages;

import java.io.File;
import java.io.IOException;
import java.util.*;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;

import org.w3c.dom.Document;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;
import org.xml.sax.SAXParseException;




public class Languages{ 
	
	ArrayList<Language> languages;
	public Document document;

	public Languages(){		
		languages = createLanguagesList();
	}
	
	public ArrayList<Language> createLanguagesList(){

		DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
		languages = new ArrayList<Language>();
		try {
			
			DocumentBuilder builder = factory.newDocumentBuilder();
			this.document = builder.parse( new File(".." + File.separator + "XML" + File.separator + "Languages" + File.separator + "languages.xml" ));
			Node rootNode = this.document.getFirstChild();
			return getLanguages(rootNode);
			
		}catch (ParserConfigurationException pce) {
			// Parser with specified options can't be built
			pce.printStackTrace();
		}catch (SAXParseException spe) {
			// Error generated by the parser
			System.out.println("\n** Parsing error"
					+ ", line " + spe.getLineNumber()
					+ ", uri " + spe.getSystemId());
			System.out.println(" " + spe.getMessage() );
			//		 Use the contained exception, if any
			Exception x = spe;
			if (spe.getException() != null)
				x = spe.getException();
			x.printStackTrace();
		}catch (SAXException sxe) {
			// Error generated during parsing
			Exception x = sxe;
			if (sxe.getException() != null)
				x = sxe.getException();
			x.printStackTrace();
		} catch (IOException ioe) {
			// I/O error
			ioe.printStackTrace();
		}
		return null;

	}
	// This method gets the active child from the DOM tree.
	public ArrayList<Language> getLanguages(Node n)
	{
		NodeList nodeList = n.getChildNodes();
		int nodeListLength = nodeList.getLength();
		
		for (int i=0; i < nodeListLength; i++) {
				Language lang = new Language();
			
				Node subNode = nodeList.item(i);
				
				if (subNode.getNodeName().compareTo("language") == 0)
				{
					NamedNodeMap attributes = subNode.getAttributes();
							
					lang.setName(attributes.getNamedItem("name").getNodeValue());

					lang.setLexer(attributes.getNamedItem("lexer").getNodeValue());
					lang.setParser(attributes.getNamedItem("parser").getNodeValue());
					lang.setReturnClass(attributes.getNamedItem("returnClass").getNodeValue());
					lang.setStartRule(attributes.getNamedItem("startRule").getNodeValue());
					lang.setCaseSensitive(Boolean.parseBoolean(attributes.getNamedItem("caseSensitive").getNodeValue()));

					NodeList subNodeList = subNode.getChildNodes();
					
					for (int j = 0; j < subNodeList.getLength(); j++){
						Node subSubNode = subNodeList.item(j);
						if (subSubNode.getNodeName().compareTo("extension") == 0)
							lang.addExtension(subSubNode.getTextContent());
					}
					languages.add(lang);
				}
			
				//lang.clearFields();
			}
			return languages;
	}
	
	public Language findLanguage(String extension){
//		languages = createLanguagesList();
		for (int i = 0; i < languages.size(); i++){
			ArrayList<String> extensions = ((Language)languages.get(i)).getExtensions();
			for(int j =0; j<extensions.size(); j++){
				if(extensions.get(j).toString().compareToIgnoreCase(extension)==0){
					return (Language)languages.get(i);
				}
			}
		}
		return null;
		
	}
	
	public int getNumberOfLanguages(){
		int length = 0;
		Iterator<Language> it = languages.iterator();
		while (it.hasNext()) {
			length++;
			it.next();
		}
		return length;
		
		
	}
	
	public Language getLanguage(int index){
		return languages.get(index);	
		
	}

}
